\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{framed}
\usepackage{epstopdf}
\usepackage[spanish]{babel}
\usepackage{appendix}
\usepackage[usenames,dvipsnames,table]{xcolor}
\usepackage{minted}
\usepackage[a4paper]{geometry}

\newminted{vhdl}{mathescape, linenos, numbersep=15pt, frame=lines,framesep=2mm}
               
\newminted{matlab}{mathescape, linenos, numbersep=15pt, frame=lines,framesep=2mm}               

\definecolor{bg}{rgb}{0.95,0.95,0.95}


% Allow the change of line spacing
\usepackage{setspace}
\usepackage{tabularx}
\usepackage{graphicx}


%\usepackage{hyperref}
%\usepackage{breakurl}

%opening
%\title{Trainmining}
%\author{Grupo de Sistemas Inteligentes \\ Universidad Politécnica de Madrid}


\begin{document}
\newcommand\litem[1]{\item{\bfseries #1 }}
\renewcommand{\arraystretch}{1.5} %Makes tables less crammed

\newcommand\headcell[1]{%
  \multicolumn{1}{c|}{\cellcolor{MidnightBlue}\bfseries\sffamily\textcolor{white}{#1}}
}
\newcommand\headcelld[1]{%
  \multicolumn{1}{c||}{\cellcolor{MidnightBlue}\bfseries\sffamily\textcolor{white}{#1}}
}

%\renewcommand{\abstractname}{Executive Summary}
%\begin{abstract}
%
%\end{abstract}

% Set line spacing to 1.5
%\onehalfspacing

\include{report1_titlepage}
%\maketitle

\newpage
\tableofcontents % indice de contenidos
\addcontentsline{toc}{section}{Contenidos} % para que aparezca en el indice de 

\section{Introducción}
En esta memoria vamos a tratar un proyecto realizado para la asignatura \emph{Diseño de Circuitos y Sistemas Electrónicos} impartida en la ETSI de Telecomunicación de la Universidad Politécnica de Madrid.

El proyecto se propone como trabajo adicional a la asignatura, para tratar los temas de diseño de circuitos digitales de una forma más práctica y obtener conocimientos mucho más amplios sobre tecnologías relacionadas con estos campos.

En concreto, la propuesta consiste en el diseño y simulación de un sistema utilizando VHDL. El sistema propuesto consiste en un ecualizador de audio, del cual se implementarán algunos subsistemas de procesado digital en VHDL. Esta práctica se apoya sobre el trabajo realizado en el año anterior en el \emph{Laboratorio de Sistemas Electrónicos Digitales}, donde se realizó este sistema utilizando un microcontrolador.

El esquema de dicho sistema puede verse en la figura~\ref{fig:sysdesc}. El proyecto que nos ocupa se centrará en la realización del subsistema de procesado digital de audio, cuyo esquema puede verse en la figura~\ref{fig:digproc}.

Para la realización del proyecto se ha utilizado la herramienta ModelSim. De forma auxiliar, se utilizará la herramienta MATLAB para el tratamiento de las señales obtenidas de forma sencilla y eficiente, para poder así evaluar el funcionamiento del sistema.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/system_description.png} 
\caption{Descripcción del sistema completo} \label{fig:sysdesc}
\end{figure}

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/digital_proc.png} 
\caption{Descripcción del subsistema de procesado digital} \label{fig:digproc}
\end{figure}

\subsection{Descripción de los módulos VHDL}
El subsistema digital representado en la figura~\ref{fig:digproc} se va a dividir en los siguientes módulos principales VHDL:
\begin{description}
\item[Banco de filtros] Este módulo incluye los 7 filtros digitales que separarán la señal de entrada en sus diferentes bandas de frecuencia. Incluye 7 submódulos correspondientes a los 7 filtros digitales. Además, este módulo ofrece la funcionalidad de selección de ganancia, como se explicará posteriormente.
\item[Módulo de reverberación] Este módulo sirve para retardar y atenuar una señal. Se utilizará para realimentar en el banco de filtros la salida retardada hasta la entrada, para generar un efecto de reverberación. El subsistema de retardo se ha implementado independientemente como un submódulo.
\item[Vúmetro] Proporciona información sobre el nivel de señal de cada una de las bandas de audio. Consiste en 7 elementos vúmetro individuales que se agrupan para obtener el vúmetro de 7 bandas.
\end{description}

Todo ello se ha agrupado en un único módulo \emph{ecualizador}, para facilitar la simulación y la ejecución de pruebas. La relación de módulos y señales puede verse en la figura~\ref{fig:vhdl_schema}.

Por último, se han implementado sumadores y multiplicadores con las estructuras estudiadas en clase. Como mejora, se han sustituido las operaciones de suma y multiplicación de señales en el sistema mediante funciones VHDL (operadores + y *) por sumas y productos obtenidos mediante sumadores y multiplicadores más realistas.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/vhdl_schema.pdf} 
\caption{Relación de módulos VHDL} \label{fig:vhdl_schema}
\end{figure}

\section{Diseño de banco de filtros}
El sistema propuesto se trata de un ecualizador de audio, por lo que las señales de entrada que tendremos estarán comprendidas en el rango de frecuencias audibles por el hombre. En concreto, la especificación del sistema propuesto propone señales cuya frecuencia estará comprendida aproximadamente entre los 22 Hz y los 2.8 KHz.

Este rango de frecuencias se dividirá en 7 bandas, para lo cual utilizaremos filtros IIR de segundo orden. Las bandas de frecuencias se detallan en la tabla \ref{tab:filters}, y los coeficientes para la realización de los filtros IIR en la tabla \ref{tab:filters}.

\begin{table}
\begin{center}
 \begin{tabular}{|c||c|c|c|}
\hline 

\headcelld{Banda} & \headcell{$f_0$} & \headcell{$f_{c1}$} & \headcell{$f_{c2}$} \\ 
\hline
\hline 
0 & 31.25 & 22.10 & 44.19 \\ 
\hline 
1 & 62.5 & 44.19 & 88.39 \\ 
\hline 
2 & 125 & 88.39 & 176.78 \\ 
\hline 
3 & 250 & 176.78 & 353.55 \\ 
\hline 
4 & 500 & 323.55 & 704.11 \\ 
\hline 
5 & 1000 & 707.11 & 1414.21 \\ 
\hline 
6 & 2000 & 1414.21 & 2828.43 \\ 
\hline 
\end{tabular} 
\caption{Descripción de las distintas bandas y sus filtros asociados} \label{tab:bands}
\end{center}
\end{table}

\begin{table}
\begin{center}
 \begin{tabular}{|c||c||c|c|c||c|c|c|}
\headcelld{Filtro} & \headcelld{Ganancia} & \headcell{$a_0$} & \headcell{$a_1$} & \headcelld{$a_2$} & \headcell{$b_0$} & \headcell{$b_1$} & \headcell{$b_2$} \\ 
\hline
\hline 
0 & 8 & 1024 & -2029 & 1006 & 1024 & 0 & -1024  \\ 
\hline 
1 & 17 & 1024 & -2011 & 988 & 1024 & 0 & -1024 \\ 
\hline 
2 & 34 & 1024 & -1970 & 955 & 1024 & 0 & -1024 \\ 
\hline 
3 & 66 & 1024 & -1878 & 890 & 1024 & 0 & -1024 \\ 
\hline 
4 & 125 & 1024 & -1660 & 772 & 1024 & 0 & -1024 \\ 
\hline 
5 & 227 & 1024 & -1115 & 569 & 1024 & 0 & -1024 \\ 
\hline 
6 & 392 & 1024 & 141 & 239 & 1024 & 0 & -1024 \\ 
\hline 
\end{tabular} 
\caption{Descripción de los coeficientes de los filtros IIR} \label{tab:filters}
\end{center}
\end{table}

\subsection{Implementación de los filtros en VHDL}
Para una implementación más sencilla de los filtros, utilizaremos la \emph{Forma directa II}. El detalle de esta implementación se puede ver en la figura \ref{fig:filter_diagram}.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/filter.png} 
\caption{Diagrama de bloques de un filtro IIR de segundo orden} \label{fig:filter_diagram}
\end{figure}

A la hora de implementar estos filtros digitales, tenemos que tener en cuenta una limitación muy importante. Debemos definir un ancho de palabra fijo para la representación de las señales de entrada y de salida. En nuestro caso, hemos escogido un ancho de palabra de \emph{16 bits}, correspondientes a \emph{6 bits enteros} y \emph{10 bits fraccionarios}. Esto es especialmente conveniente a la hora de representar los coeficientes de los filtros, ya que para todos ellos tenemos que $a_0 = 1024$. Normalizar los coeficientes realizando una división por 1024 equivale a desplazar los bits 10 lugares a la derecha (o lo que es lo mismo, la coma decimal 10 lugares a la izquierda). De esta forma, cuando representemos los coeficientes enteros como palabras binarias de 16 bits, bastará como tomar los 10 bits menos significativos como fraccionarios para tener el coeficiente normalizado a 1024.

\subsection{Ruido de cuantificación}
El haber elegido un ancho de palabra de 16 bits con 6 bits enteros y 10 fraccionarios nos impone una limitación considerable en cuanto a la resolución de nuestro sistema a la hora de representar señales. Sobretodo en señales de amplitud baja, tendremos un ruido de cuantificación que puede llegar a influir en el correcto funcionamiento de nuestro sistema.

Para intentar minimizar el ruido de cuantificación, se puede intentar ajustar más el numero de bits enteros, ya que las señales con las que trabajaremos estan normalizadas a 1, y a priori debería bastarnos con un bit entero y 15 fraccionarios. Este enfoque se ha intentado realizar sin éxito en la implementación, ya que aunque las señales de entrada esten normalizadas a 1, en puntos intermedios de los filtros algunas señales pueden tomar valores más altos, produciendo desbordamiento. Por ello, se ha decidido tomar una postura más conservadora y mantener la representación con 10 bits fraccionarios, que aunque no es óptima en sentido del ruido de cuantificación, nos ofrece mayor seguridad frente a desbordamiento.

Otra forma de abordar este problema sería utilizar palabras de 32 bits en lugar de 16. Esto nos ofrecería una resolución enormemente mayor, mejorando sensiblemente la calidad del sistema. No obstante, trabajar con palabras de 32 bits supone una complejidad mucho mayor a la hora de implementar los sumadores y multiplicadores vistos en clase. Debido a que el objetivo del proyecto es mayormente didáctico y no obtener una calidad de audio excepcional, se ha decidido mantener las palabras de 16 bits y asumir los efectos del ruido de cuantificación.

\subsection{Ajuste de ganancias}
Además de separar la señal en 7 bandas de frecuencias, el banco de filtros de nuestro sistema debe aplicar a cada uno una ganancia ajustable y disponer a la salida de la señal global sumada.

La selección de ganancia para cada banda se realiza mediante 3 entradas adicionales:
\begin{description}
\item[Entrada f\_sel] Entrada de 3 bits mediante la cual seleccionamos el filtro (de 0 a 6) cuya ganancia queremos ajustar.
\item[Entrada g\_sel] Entrada de 4 bits mediante la cual seleccionamos la ganancia que queremos aplicar al filtro seleccionado. Estas ganancias se encuentran definidas en el propio sistema en forma de tabla, de forma que a cada uno de los valores 0 a 15 le corresponde un valor de ganancia predefinido.
\item[Entrada g\_en] Señal de \emph{enable} del sistema de selección de ganancia. Cuando se detecta un flanco de subida se aplica la ganancia seleccionada al filtro seleccionado.
\end{description}

Para evitar desbordamiento en la señal al aplicar la ganancia, trabajaremos con posibles valores de ganancia menores que 1 (atenuaremos la señal). De esta forma, la ganancia numero 0 corresponde a una ganancia de 0dB, y de ahí se irá bajando a medida que aumente el índice de la ganancia seleccionada.

\section{Diseño de módulo de reverberación}
El subsistema de reverberación consiste en un módulo que ofrece a la salida la señal que obtiene a la entrada con un retraso de N posiciones y aplicandole una atenuación determinada.

Para la implementación de este módulo se ha utilizado como base una cola FIFO, en la cual se va introduciendo la señal que posteriormente se va obteniendo por la salida tras N ciclos de reloj. Para ello es importante inicializar la cola para que esté llena de palabras a cero, ya que si no la primera muestra de la señal de entrada ocuparía la primera posición y sería la que se ofrecería a la salida en el siguiente ciclo de reloj.

En nuestro sistema, el numero de palabras en la cola será siempre fijo e igual al número de muestras que queramos retrasar la señal. La implementación de una cola FIFO tiene cierta complejidad derivada del hecho de que el numero de palabras en la cola es variable y puede ser impredecible, conllevando posibles problemas de desbordamiento o cola vacía. Sin embargo, puesto que el funcionamiento de nuestro retardador es mucho más predecible (llegará una muestra por cada ciclo de reloj y sacaremos una muestra por cada ciclo de reloj, resultando en un tamaño constante) podemos simplificar considerablemente este diseño.

Se ha implementado para ello el subsistema \emph{delay}, que consiste en una memoria de N posiciones (tamaño configurable mediante genéricos) con un puntero señalando a una de esas posiciones. En cada ciclo de reloj, se sacará la señal de la posición indicada por el puntero y se añadirá en su lugar la señal que llegue a la entrada. El valor del puntero se va aumentando de forma cíclica, de forma que la señal que acabamos de introducir no se sacará hasta que el puntero vuelva a apuntar a esa misma posición, es decir, tras N ciclos de reloj.

Posteriormente, la señal se atenúa mediante un valor de ganancia también configurable mediante genéricos, y se realimenta a la entrada del banco de filtros.
\section{Diseño de vúmetro}
El vúmetro ofrece información sobre el nivel de señal disponible en cada una de las bandas de señal. Para abordar la implementación de este módulo, se ha implementado un subsistema vúmetro con úna única entrada que ofrece el nivel de la señal que tenga a la entrada. Estos vúmetros individuales se agrupan en un módulo vúmetro de 7 entradas, que conectaremos a la salida de cada uno de los filtros del banco de filtros.

Cada uno de los vúmetros individuales generan a la salida una señal de 8 bits, simulando los leds que tradicionalmente se utilizan en estos sistemas. El número de bits que se pongan a 1 en la señal (leds que se iluminan) indicará el nivel de la señal en esa banda.

Para detectar el nivel de la señal, observaremos la palabra a nivel binario. Una palabra de la señal está representada de la siguiente forma:
$$X_{15} X_{14} X_{13} X_{12} X_{11} X_{10} X_{9} X_{8} X_{7} X_{6} X_{5} X_{4} X_{3} X_{2} X_{1} X_{0}$$
Definiremos cada uno de los 8 niveles de señal dividiendo los 16 bits en conjuntos de dos. Así, el nivel 0 corresponderá a todos los bits a 0, el nivel 1 se alcanzará cuando sólo los bits $X_1$ o $X_0$ estén a nivel alto, el nivel 2 si los bits $X_4$ o $X_3$ están a 1, y así sucesivamente. cada uno de estos niveles \emph{encenderá} a la salida el led correspondiente a su nivel además de todos los de los niveles anteriores.

Para tener en cuenta las posibles palabras negativas en complemento a dos, es importante tener en cuenta que debemos observar siempre el valor absoluto de las señales, ya que si no siempre obtendríamos el nivel más alto para cualquier entrada negativa.

\subsection{Mantenimiento del nivel}
Debido a las posibles variaciones rápidas de la señal, es importante que los picos a la salida del vúmetro se mantengan un mínimo tiempo para su correcta visualización.

Para implementar este comportamiento, se ha definido el siguiente procedimiento:
\begin{enumerate}
\item Se toma una muestra a la entrada y se mantiene en memoria
\item Se inicia un contador (configurable mediante genéricos) que indica el tiempo mínimo que se han de mantener los niveles a la salida
\item Si a la entrada llega alguna muestra mayor a la que tenemos en memoria, se sustituye y se reinicia el contador, comenzando el proceso desde el principio.
\item Si el contador llega a cero, se elimina la señal de memoria, permitiendo que otras señales más bajas tomen el lugar de la muestra. En este punto el pico anterior deja de mantenerse y el nivel del vúmetro puede bajar
\item La siguiente muestra entra en memoria y se reinicia el proceso
\end{enumerate}

Esto nos permite mantener de forma sencilla los niveles un mínimo de tiempo en pantalla sin perder información de posibles picos que puedan aparecer mientras estamos manteniendo la señal.

\section{Mejoras}
Para la aplicación de los conocimientos obtenidos en la asignatura \emph{Diseño de Circuitos y Sistemas Electrónicos}, se ha propuesto la realización de varias modificaciones que se corresponden con lo estudiado en la parte digital de la asignatura.

En concreto, se ha propuesto la implementación de sumadores y multiplicadores binarios, correspondiendose con las configuraciones estudiadas en clase. Estas implementaciones se han de realizar a bajo nivel, mediante la conexión y configuración de \emph{Full Adders}, ilustrando además los efectos de retardo en cada una de las distintas configuraciones.

En concreto, se han implementado las siguientes configuraciones:
\begin{itemize}
\item Sumador ripple carry
\item Sumador carry bypass
\item Multiplicador en array
\item Multiplicador carry save
\end{itemize}

Se ha supuesto para ello un retardo en los \emph{Full Adder} fijo de 1 ns, tanto en la generación de la señal de suma como en la señal de carry. Esto nos permite observar el efecto de los distintos caminos críticos en el retardo en la generación de las señales.

\subsection{Sumador Ripple Carry}
Este sumador es el más sencillo en términos de implementación. Simplemente se han conectado 16 full adders de forma secuencial de forma que el acarreo se propague de uno a otro.

En la figura~\ref{fig:ripple_carry_adder} se muestra un esquema simplificado (4 bits) de este sumador.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/ripple_carry_adder.png} 
\caption{Sumador Ripple Carry de 4 bits} \label{fig:ripple_carry_adder}
\end{figure}

\subsection{Sumador Carry Bypass}
El sumador \emph{Carry Bypass} (o \emph{Carry Skip}) permite reducir el tiempo de retardo del camino crítico sensiblemente. En la figura~\ref{fig:carry_bypass_adder} puede verse un esquema de este tipo de sumador.

Para la implementación de este tipo de sumadores, se divide la operación en varios bloques. En el esquema de la figura~\ref{fig:carry_bypass_adder} estos bloques son de 4 bits, aunque se puede variar el tamaño de los mismos para optimizar aún más el retardo de este sumador.

En la figura~\ref{fig:carry_skip_block} puede verse un detalle de los bloques carry bypass.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/carryskipblock.png} 
\caption{Bloque carry bypass} \label{fig:carry_skip_block}
\end{figure}

En nuestro diseño, se ha optado por un tamaño de bloque de 4 bits, lo que resulta en un total de 4 bloques carry bypass para obtener el sumador completo. Para trabajar con las señales P y G que se han explicado en teoría, se ha implementado una versión modificada del full adder que trabaja con las señales P y G en lugar de los sumandos originales.

\subsection{Multiplicador en array}
El multiplicador en array corresponde a la implementación más directa de una multiplicación binaria. Para ello, simplemente se generan los productos parciales y se van sumando en distintas filas de sumadores. Esto conlleva un retardo considerablemente alto, que como podremos ver, se puede reducir mediante otras configuraciones de multiplicadores.

En la figura~\ref{fig:array_multiplier} se puede ver un esquema general de un multiplicador en array. Para un multiplicador de 16 x 16 bits como el que necesitamos en nuestro sistema, tendríamos que utilizar un total de 256 full adders. Debido a que esta cantidad es inmanejable a la hora de realizar conexiones de señales en VHDL, se ha optado por dividir la estructura del multiplicador en filas de 16 full adders, de forma que solo tengamos que diseñar una fila y después tratar con 16 filas. El diseño de estas filas (\emph{bloques de multiplicador en array}) puede verse en la figura~\ref{fig:array_multiplier_block}. Es importante destacar que esta agrupación en filas no conlleva ninguna modificación en el funcionamiento del multiplicador, y que equivale exactamente a haber conectado entre si los 256 full adders en un único módulo.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/array_multiplier.png} 
\caption{Multiplicador en array} \label{fig:array_multiplier}
\end{figure}

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/array_mult_block.pdf} 
\caption{Bloque de multiplicador en array} \label{fig:array_multiplier_block}
\end{figure}

\subsection{Multiplicador carry save}
El multiplicador carry save es una estrucutra de multiplicador modificada que permite reducir el tiempo de retardo en la generación del producto. Para ello, los acarreos de una fila de full adders no son propagados dentro de una misma fila, sino que se propagan a la fila siguiente como un sumando adicional.

El esquema de este tipo de multiplicador puede verse en la figura~\ref{fig:carry_save_multiplier}.

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/carry_save_mult.png} 
\caption{Multiplicador carry save} \label{fig:carry_save_multiplier}
\end{figure}

De forma análoga a lo que sucede con el multiplicador en array, realizar un multiplicador carry save de 16x16 bits conlleva la utilización de un número inmanejable de full adders. Para evitar este problema, se ha optado por una solución similar a la tomada para la implementación del multiplicador en array: dividir el sistema en bloques para cada fila de full adders.

El diseño elegido para estos bloques puede verse en la figura~\ref{fig:carry_save_block}

\begin{figure}[hbt]
\includegraphics[width=\textwidth]{img/carry_save_block.png} 
\caption{Bloque del multiplicador carry save} \label{fig:carry_save_block}
\end{figure}


\end{document}













